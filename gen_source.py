import sys


headers = """
#include "{name}.h"

#include <stdint.h>  // for uint8_t
"""

pack_headers = """#include <stdlib.h>  // for free, malloc
"""


block_impl = """
void Block_{mc}_{nc}_{kc}(uint8_t *restrict A, uint8_t *restrict B, uint8_t *restrict C) {{
  for (int m = 0; m < M; m += {mc}) {{
    for (int n = 0; n < N; n += {nc}) {{
      for (int k = 0; k < K; k += {kc}) {{
        // Macrokernel
        for (int mm = m; mm < m + {mc}; ++mm) {{
          for (int nn = n; nn < n + {nc}; ++nn) {{
            // Microkernel
            for (int kk = k; kk < k + {kc}; ++kk) {{
              C[mm * N + nn] += A[mm * K + kk] * B[kk * N + nn];
            }}
          }}
        }}
      }}
    }}
  }}
}}
"""


pack_impl_body = """
  for (int n = 0; n < N; n += {nc}) {{
    for (int k = 0; k < K; k += {kc}) {{
      // Pack into B
      for (int kk = k; kk < k + {kc}; ++kk) {{
        for (int nn = n; nn < n + {nc}; ++nn) {{
          B_block[(kk - k) * {nc} + (nn - n)] = B[kk * N + nn];
        }}
      }}

      for (int m = 0; m < M; m += {mc}) {{
        // Pack into A
        for (int mm = m; mm < m + {mc}; ++mm) {{
          for (int kk = k; kk < k + {kc}; ++kk) {{
            A_block[(mm - m) * {kc} + (kk - k)] = A[mm * K + kk];
          }}
        }}

        // Macrokernel
        for (int nn = 0; nn < {nc}; ++nn) {{
          for (int mm = 0; mm < {mc}; ++mm) {{
            // Microkernel
            for (int kk = 0; kk < {kc}; ++kk) {{
              C[(m + mm) * N + (n + nn)] +=
                  A_block[mm * {kc} + kk] * B_block[kk * {nc} + nn];
            }}
          }}
        }}
      }}
    }}
  }}
"""


STACK_CUTOFF = 256


def pack_impl_prologue(mc, nc, kc):
    code = """
void Pack_{mc}_{nc}_{kc}(uint8_t *A, uint8_t *B, uint8_t *restrict C) {{"""

    if (kc * nc) * 1 < STACK_CUTOFF:  # uint8_t (1 byte)
        # Stack allocation
        code += """
  uint8_t B_block[{kc} * {nc}];"""
    else:
        # Heap allocation
        code += """
  uint8_t *restrict B_block = (uint8_t *)malloc({kc} * {nc} * sizeof(uint8_t));"""

    if (mc * kc) * 1 < STACK_CUTOFF:  # uint8_t (1 byte)
        # Stack allocation
        code += """
  uint8_t A_block[{mc} * {kc}];
"""
    else:
        # Heap allocation
        code += """
  uint8_t *restrict A_block = (uint8_t *)malloc({mc} * {kc} * sizeof(uint8_t));
"""

    return code.format(mc=mc, nc=nc, kc=kc)


def pack_impl_epilogue(mc, nc, kc):
    code = ""

    if (mc * kc) * 1 >= STACK_CUTOFF:  # uint8_t (1 byte)
        # Heap allocation
        code += """
    free(A_block);"""

    if (kc * nc) * 1 >= STACK_CUTOFF:  # uint8_t (1 byte)
        # Heap allocation
        code += """
    free(B_block);"""

    code += """
}
"""
    return code


# name: Block or Pack
def generate_code(size, name):
    size = int(size)

    code = "/* Autogenerated file. Do not edit manually. */\n"
    code += headers.format(name=name)

    if name == "Block":
        pass
    elif name == "Pack":
        code += pack_headers
    else:
        raise ValueError("Unknown name: {}".format(name))

    for mc in range(0, size + 1):
        for nc in range(0, size + 1):
            for kc in range(0, size + 1):
                if name == "Block":
                    code += block_impl.format(mc=2**mc, nc=2**nc, kc=2**kc)
                elif name == "Pack":
                    code += pack_impl_prologue(mc=2**mc, nc=2**nc, kc=2**kc)
                    code += pack_impl_body.format(mc=2**mc, nc=2**nc, kc=2**kc)
                    code += pack_impl_epilogue(mc=2**mc, nc=2**nc, kc=2**kc)
    return code


if __name__ == "__main__":
    size, name = sys.argv[1:3]
    print(generate_code(size, name))
