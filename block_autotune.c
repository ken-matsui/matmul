/* Autogenerated file. Do not edit manually. */

#include <stdarg.h>  // for va_list, va_start, va_end
#include <stdint.h>  // for uint8_t
#include <stdio.h>   // for vprintf, vfprintf, FILE, fclose, fopen
#include <stdlib.h>  // for rand, free, posix_memalign
#include <limits.h>  // for ULLONG_MAX
#include <time.h>    // for clock_gettime, timespec, CLOCK_MONOTONIC

#include "./Bench.h"
#include "./Block.h"

static void tee(const char *format, ...) {
  va_list args;

  // Print to stdout
  va_start(args, format);
  vprintf(format, args);
  va_end(args);

  // Print to file
  FILE *fp = fopen("Block_autotune.txt", "a");
  va_start(args, format);
  vfprintf(fp, format, args);
  va_end(args);
  fclose(fp);
}

static unsigned long long call_kernel_1_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_4_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_4_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_4_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 4, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_8_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_8_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_8_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 8, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_16_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_16_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_16_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 16, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_32_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_32_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_32_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 32, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_64_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_64_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_64_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 64, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_128_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_128_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_128_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 128, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_256_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_256_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_256_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 256, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_512_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_512_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_512_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 512, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_1024_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_1024_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_1024_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 1024, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_4_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_4_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_4_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 4, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_8_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_8_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_8_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 8, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_16_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_16_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_16_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 16, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_32_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_32_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_32_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 32, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_64_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_64_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_64_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 64, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_128_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_128_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_128_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 128, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_256_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_256_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_256_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 256, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_512_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_512_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_512_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 512, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_1024_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_1024_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_1024_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 1024, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_1(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_1(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_1(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 1,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_2(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_2(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_2(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 2,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_4(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_4(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_4(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 4,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_8(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_8(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_8(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 8,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_16(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_16(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_16(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 16,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_32(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_32(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_32(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 32,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_64(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_64(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_64(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 64,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_128(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_128(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_128(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 128,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_256(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_256(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_256(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 256,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_512(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_512(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_512(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 512,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_1024(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_1024(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_1024(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 1024,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

static unsigned long long call_kernel_2048_2048_2048(void) {
  uint8_t *A;
  posix_memalign((void **)&A, 128, M * K * sizeof(uint8_t));
  for (int i = 0; i < M * K; ++i) {
    A[i] = (uint8_t)rand();
  }

  uint8_t *B;
  posix_memalign((void **)&B, 128, K * N * sizeof(uint8_t));
  for (int i = 0; i < K * N; ++i) {
    B[i] = (uint8_t)rand();
  }

  uint8_t *restrict C;
  posix_memalign((void **)&C, 128, M * N * sizeof(uint8_t));
  for (int i = 0; i < M * N; ++i) {
    C[i] = 0;
  }

  // Inlined kernel follows. This is for warm-up.
  Block_2048_2048_2048(A, B, C);

  struct timespec start, end;
  unsigned long long total_time = 0;
  const int num_iterations = 10;
#pragma clang loop unroll(disable)
  for (int i = 0; i < num_iterations; ++i) {
    clock_gettime(CLOCK_MONOTONIC, &start);
    Block_2048_2048_2048(A, B, C);
    clock_gettime(CLOCK_MONOTONIC, &end);

    struct timespec diff = TsDiff(start, end);
    total_time += ToNs(diff);
    tee("%d: %lds %09ldns\n", i, diff.tv_sec, diff.tv_nsec);
  }
  unsigned long long avg_time = total_time / num_iterations;
  struct timespec avg_time_ts = ToTs(avg_time);
  tee("(mc: %d, nc: %d, kc: %d): ave. %lds %09ldns\n", 2048, 2048, 2048,
      avg_time_ts.tv_sec, avg_time_ts.tv_nsec);

  free(A);
  free(B);
  free(C);

  return avg_time;
}

struct Param {
  int mc;
  int nc;
  int kc;
};

int main(void) {
  unsigned long long min_time = ULLONG_MAX;
  struct Param min_param = {0, 0, 0};
  unsigned long long avg_time;

  // Erase the existing content of the file.
  FILE *fp = fopen("Block_autotune.txt", "w");
  if (fp) {
    fclose(fp);
  }

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 1);
  avg_time = call_kernel_1_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 2);
  avg_time = call_kernel_1_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 4);
  avg_time = call_kernel_1_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 8);
  avg_time = call_kernel_1_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 16);
  avg_time = call_kernel_1_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 32);
  avg_time = call_kernel_1_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 64);
  avg_time = call_kernel_1_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 128);
  avg_time = call_kernel_1_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 256);
  avg_time = call_kernel_1_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 512);
  avg_time = call_kernel_1_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 1024);
  avg_time = call_kernel_1_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1, 2048);
  avg_time = call_kernel_1_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 1);
  avg_time = call_kernel_1_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 2);
  avg_time = call_kernel_1_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 4);
  avg_time = call_kernel_1_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 8);
  avg_time = call_kernel_1_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 16);
  avg_time = call_kernel_1_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 32);
  avg_time = call_kernel_1_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 64);
  avg_time = call_kernel_1_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 128);
  avg_time = call_kernel_1_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 256);
  avg_time = call_kernel_1_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 512);
  avg_time = call_kernel_1_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 1024);
  avg_time = call_kernel_1_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2, 2048);
  avg_time = call_kernel_1_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 1);
  avg_time = call_kernel_1_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 2);
  avg_time = call_kernel_1_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 4);
  avg_time = call_kernel_1_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 8);
  avg_time = call_kernel_1_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 16);
  avg_time = call_kernel_1_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 32);
  avg_time = call_kernel_1_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 64);
  avg_time = call_kernel_1_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 128);
  avg_time = call_kernel_1_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 256);
  avg_time = call_kernel_1_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 512);
  avg_time = call_kernel_1_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 1024);
  avg_time = call_kernel_1_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 4, 2048);
  avg_time = call_kernel_1_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 1);
  avg_time = call_kernel_1_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 2);
  avg_time = call_kernel_1_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 4);
  avg_time = call_kernel_1_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 8);
  avg_time = call_kernel_1_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 16);
  avg_time = call_kernel_1_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 32);
  avg_time = call_kernel_1_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 64);
  avg_time = call_kernel_1_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 128);
  avg_time = call_kernel_1_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 256);
  avg_time = call_kernel_1_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 512);
  avg_time = call_kernel_1_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 1024);
  avg_time = call_kernel_1_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 8, 2048);
  avg_time = call_kernel_1_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 1);
  avg_time = call_kernel_1_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 2);
  avg_time = call_kernel_1_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 4);
  avg_time = call_kernel_1_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 8);
  avg_time = call_kernel_1_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 16);
  avg_time = call_kernel_1_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 32);
  avg_time = call_kernel_1_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 64);
  avg_time = call_kernel_1_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 128);
  avg_time = call_kernel_1_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 256);
  avg_time = call_kernel_1_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 512);
  avg_time = call_kernel_1_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 1024);
  avg_time = call_kernel_1_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 16, 2048);
  avg_time = call_kernel_1_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 1);
  avg_time = call_kernel_1_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 2);
  avg_time = call_kernel_1_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 4);
  avg_time = call_kernel_1_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 8);
  avg_time = call_kernel_1_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 16);
  avg_time = call_kernel_1_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 32);
  avg_time = call_kernel_1_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 64);
  avg_time = call_kernel_1_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 128);
  avg_time = call_kernel_1_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 256);
  avg_time = call_kernel_1_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 512);
  avg_time = call_kernel_1_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 1024);
  avg_time = call_kernel_1_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 32, 2048);
  avg_time = call_kernel_1_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 1);
  avg_time = call_kernel_1_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 2);
  avg_time = call_kernel_1_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 4);
  avg_time = call_kernel_1_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 8);
  avg_time = call_kernel_1_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 16);
  avg_time = call_kernel_1_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 32);
  avg_time = call_kernel_1_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 64);
  avg_time = call_kernel_1_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 128);
  avg_time = call_kernel_1_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 256);
  avg_time = call_kernel_1_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 512);
  avg_time = call_kernel_1_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 1024);
  avg_time = call_kernel_1_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 64, 2048);
  avg_time = call_kernel_1_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 1);
  avg_time = call_kernel_1_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 2);
  avg_time = call_kernel_1_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 4);
  avg_time = call_kernel_1_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 8);
  avg_time = call_kernel_1_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 16);
  avg_time = call_kernel_1_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 32);
  avg_time = call_kernel_1_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 64);
  avg_time = call_kernel_1_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 128);
  avg_time = call_kernel_1_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 256);
  avg_time = call_kernel_1_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 512);
  avg_time = call_kernel_1_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 1024);
  avg_time = call_kernel_1_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 128, 2048);
  avg_time = call_kernel_1_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 1);
  avg_time = call_kernel_1_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 2);
  avg_time = call_kernel_1_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 4);
  avg_time = call_kernel_1_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 8);
  avg_time = call_kernel_1_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 16);
  avg_time = call_kernel_1_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 32);
  avg_time = call_kernel_1_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 64);
  avg_time = call_kernel_1_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 128);
  avg_time = call_kernel_1_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 256);
  avg_time = call_kernel_1_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 512);
  avg_time = call_kernel_1_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 1024);
  avg_time = call_kernel_1_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 256, 2048);
  avg_time = call_kernel_1_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 1);
  avg_time = call_kernel_1_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 2);
  avg_time = call_kernel_1_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 4);
  avg_time = call_kernel_1_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 8);
  avg_time = call_kernel_1_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 16);
  avg_time = call_kernel_1_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 32);
  avg_time = call_kernel_1_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 64);
  avg_time = call_kernel_1_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 128);
  avg_time = call_kernel_1_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 256);
  avg_time = call_kernel_1_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 512);
  avg_time = call_kernel_1_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 1024);
  avg_time = call_kernel_1_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 512, 2048);
  avg_time = call_kernel_1_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 1);
  avg_time = call_kernel_1_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 2);
  avg_time = call_kernel_1_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 4);
  avg_time = call_kernel_1_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 8);
  avg_time = call_kernel_1_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 16);
  avg_time = call_kernel_1_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 32);
  avg_time = call_kernel_1_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 64);
  avg_time = call_kernel_1_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 128);
  avg_time = call_kernel_1_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 256);
  avg_time = call_kernel_1_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 512);
  avg_time = call_kernel_1_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 1024);
  avg_time = call_kernel_1_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 1024, 2048);
  avg_time = call_kernel_1_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 1);
  avg_time = call_kernel_1_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 2);
  avg_time = call_kernel_1_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 4);
  avg_time = call_kernel_1_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 8);
  avg_time = call_kernel_1_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 16);
  avg_time = call_kernel_1_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 32);
  avg_time = call_kernel_1_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 64);
  avg_time = call_kernel_1_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 128);
  avg_time = call_kernel_1_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 256);
  avg_time = call_kernel_1_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 512);
  avg_time = call_kernel_1_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 1024);
  avg_time = call_kernel_1_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1, 2048, 2048);
  avg_time = call_kernel_1_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 1);
  avg_time = call_kernel_2_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 2);
  avg_time = call_kernel_2_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 4);
  avg_time = call_kernel_2_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 8);
  avg_time = call_kernel_2_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 16);
  avg_time = call_kernel_2_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 32);
  avg_time = call_kernel_2_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 64);
  avg_time = call_kernel_2_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 128);
  avg_time = call_kernel_2_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 256);
  avg_time = call_kernel_2_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 512);
  avg_time = call_kernel_2_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 1024);
  avg_time = call_kernel_2_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1, 2048);
  avg_time = call_kernel_2_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 1);
  avg_time = call_kernel_2_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 2);
  avg_time = call_kernel_2_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 4);
  avg_time = call_kernel_2_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 8);
  avg_time = call_kernel_2_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 16);
  avg_time = call_kernel_2_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 32);
  avg_time = call_kernel_2_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 64);
  avg_time = call_kernel_2_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 128);
  avg_time = call_kernel_2_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 256);
  avg_time = call_kernel_2_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 512);
  avg_time = call_kernel_2_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 1024);
  avg_time = call_kernel_2_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2, 2048);
  avg_time = call_kernel_2_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 1);
  avg_time = call_kernel_2_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 2);
  avg_time = call_kernel_2_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 4);
  avg_time = call_kernel_2_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 8);
  avg_time = call_kernel_2_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 16);
  avg_time = call_kernel_2_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 32);
  avg_time = call_kernel_2_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 64);
  avg_time = call_kernel_2_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 128);
  avg_time = call_kernel_2_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 256);
  avg_time = call_kernel_2_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 512);
  avg_time = call_kernel_2_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 1024);
  avg_time = call_kernel_2_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 4, 2048);
  avg_time = call_kernel_2_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 1);
  avg_time = call_kernel_2_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 2);
  avg_time = call_kernel_2_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 4);
  avg_time = call_kernel_2_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 8);
  avg_time = call_kernel_2_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 16);
  avg_time = call_kernel_2_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 32);
  avg_time = call_kernel_2_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 64);
  avg_time = call_kernel_2_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 128);
  avg_time = call_kernel_2_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 256);
  avg_time = call_kernel_2_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 512);
  avg_time = call_kernel_2_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 1024);
  avg_time = call_kernel_2_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 8, 2048);
  avg_time = call_kernel_2_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 1);
  avg_time = call_kernel_2_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 2);
  avg_time = call_kernel_2_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 4);
  avg_time = call_kernel_2_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 8);
  avg_time = call_kernel_2_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 16);
  avg_time = call_kernel_2_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 32);
  avg_time = call_kernel_2_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 64);
  avg_time = call_kernel_2_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 128);
  avg_time = call_kernel_2_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 256);
  avg_time = call_kernel_2_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 512);
  avg_time = call_kernel_2_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 1024);
  avg_time = call_kernel_2_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 16, 2048);
  avg_time = call_kernel_2_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 1);
  avg_time = call_kernel_2_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 2);
  avg_time = call_kernel_2_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 4);
  avg_time = call_kernel_2_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 8);
  avg_time = call_kernel_2_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 16);
  avg_time = call_kernel_2_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 32);
  avg_time = call_kernel_2_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 64);
  avg_time = call_kernel_2_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 128);
  avg_time = call_kernel_2_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 256);
  avg_time = call_kernel_2_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 512);
  avg_time = call_kernel_2_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 1024);
  avg_time = call_kernel_2_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 32, 2048);
  avg_time = call_kernel_2_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 1);
  avg_time = call_kernel_2_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 2);
  avg_time = call_kernel_2_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 4);
  avg_time = call_kernel_2_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 8);
  avg_time = call_kernel_2_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 16);
  avg_time = call_kernel_2_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 32);
  avg_time = call_kernel_2_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 64);
  avg_time = call_kernel_2_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 128);
  avg_time = call_kernel_2_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 256);
  avg_time = call_kernel_2_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 512);
  avg_time = call_kernel_2_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 1024);
  avg_time = call_kernel_2_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 64, 2048);
  avg_time = call_kernel_2_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 1);
  avg_time = call_kernel_2_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 2);
  avg_time = call_kernel_2_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 4);
  avg_time = call_kernel_2_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 8);
  avg_time = call_kernel_2_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 16);
  avg_time = call_kernel_2_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 32);
  avg_time = call_kernel_2_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 64);
  avg_time = call_kernel_2_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 128);
  avg_time = call_kernel_2_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 256);
  avg_time = call_kernel_2_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 512);
  avg_time = call_kernel_2_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 1024);
  avg_time = call_kernel_2_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 128, 2048);
  avg_time = call_kernel_2_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 1);
  avg_time = call_kernel_2_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 2);
  avg_time = call_kernel_2_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 4);
  avg_time = call_kernel_2_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 8);
  avg_time = call_kernel_2_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 16);
  avg_time = call_kernel_2_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 32);
  avg_time = call_kernel_2_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 64);
  avg_time = call_kernel_2_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 128);
  avg_time = call_kernel_2_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 256);
  avg_time = call_kernel_2_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 512);
  avg_time = call_kernel_2_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 1024);
  avg_time = call_kernel_2_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 256, 2048);
  avg_time = call_kernel_2_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 1);
  avg_time = call_kernel_2_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 2);
  avg_time = call_kernel_2_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 4);
  avg_time = call_kernel_2_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 8);
  avg_time = call_kernel_2_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 16);
  avg_time = call_kernel_2_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 32);
  avg_time = call_kernel_2_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 64);
  avg_time = call_kernel_2_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 128);
  avg_time = call_kernel_2_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 256);
  avg_time = call_kernel_2_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 512);
  avg_time = call_kernel_2_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 1024);
  avg_time = call_kernel_2_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 512, 2048);
  avg_time = call_kernel_2_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 1);
  avg_time = call_kernel_2_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 2);
  avg_time = call_kernel_2_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 4);
  avg_time = call_kernel_2_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 8);
  avg_time = call_kernel_2_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 16);
  avg_time = call_kernel_2_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 32);
  avg_time = call_kernel_2_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 64);
  avg_time = call_kernel_2_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 128);
  avg_time = call_kernel_2_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 256);
  avg_time = call_kernel_2_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 512);
  avg_time = call_kernel_2_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 1024);
  avg_time = call_kernel_2_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 1024, 2048);
  avg_time = call_kernel_2_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 1);
  avg_time = call_kernel_2_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 2);
  avg_time = call_kernel_2_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 4);
  avg_time = call_kernel_2_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 8);
  avg_time = call_kernel_2_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 16);
  avg_time = call_kernel_2_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 32);
  avg_time = call_kernel_2_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 64);
  avg_time = call_kernel_2_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 128);
  avg_time = call_kernel_2_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 256);
  avg_time = call_kernel_2_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 512);
  avg_time = call_kernel_2_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 1024);
  avg_time = call_kernel_2_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2, 2048, 2048);
  avg_time = call_kernel_2_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 1);
  avg_time = call_kernel_4_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 2);
  avg_time = call_kernel_4_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 4);
  avg_time = call_kernel_4_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 8);
  avg_time = call_kernel_4_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 16);
  avg_time = call_kernel_4_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 32);
  avg_time = call_kernel_4_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 64);
  avg_time = call_kernel_4_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 128);
  avg_time = call_kernel_4_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 256);
  avg_time = call_kernel_4_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 512);
  avg_time = call_kernel_4_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 1024);
  avg_time = call_kernel_4_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1, 2048);
  avg_time = call_kernel_4_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 1);
  avg_time = call_kernel_4_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 2);
  avg_time = call_kernel_4_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 4);
  avg_time = call_kernel_4_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 8);
  avg_time = call_kernel_4_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 16);
  avg_time = call_kernel_4_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 32);
  avg_time = call_kernel_4_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 64);
  avg_time = call_kernel_4_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 128);
  avg_time = call_kernel_4_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 256);
  avg_time = call_kernel_4_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 512);
  avg_time = call_kernel_4_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 1024);
  avg_time = call_kernel_4_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2, 2048);
  avg_time = call_kernel_4_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 1);
  avg_time = call_kernel_4_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 2);
  avg_time = call_kernel_4_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 4);
  avg_time = call_kernel_4_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 8);
  avg_time = call_kernel_4_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 16);
  avg_time = call_kernel_4_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 32);
  avg_time = call_kernel_4_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 64);
  avg_time = call_kernel_4_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 128);
  avg_time = call_kernel_4_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 256);
  avg_time = call_kernel_4_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 512);
  avg_time = call_kernel_4_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 1024);
  avg_time = call_kernel_4_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 4, 2048);
  avg_time = call_kernel_4_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 1);
  avg_time = call_kernel_4_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 2);
  avg_time = call_kernel_4_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 4);
  avg_time = call_kernel_4_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 8);
  avg_time = call_kernel_4_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 16);
  avg_time = call_kernel_4_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 32);
  avg_time = call_kernel_4_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 64);
  avg_time = call_kernel_4_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 128);
  avg_time = call_kernel_4_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 256);
  avg_time = call_kernel_4_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 512);
  avg_time = call_kernel_4_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 1024);
  avg_time = call_kernel_4_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 8, 2048);
  avg_time = call_kernel_4_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 1);
  avg_time = call_kernel_4_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 2);
  avg_time = call_kernel_4_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 4);
  avg_time = call_kernel_4_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 8);
  avg_time = call_kernel_4_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 16);
  avg_time = call_kernel_4_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 32);
  avg_time = call_kernel_4_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 64);
  avg_time = call_kernel_4_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 128);
  avg_time = call_kernel_4_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 256);
  avg_time = call_kernel_4_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 512);
  avg_time = call_kernel_4_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 1024);
  avg_time = call_kernel_4_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 16, 2048);
  avg_time = call_kernel_4_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 1);
  avg_time = call_kernel_4_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 2);
  avg_time = call_kernel_4_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 4);
  avg_time = call_kernel_4_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 8);
  avg_time = call_kernel_4_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 16);
  avg_time = call_kernel_4_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 32);
  avg_time = call_kernel_4_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 64);
  avg_time = call_kernel_4_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 128);
  avg_time = call_kernel_4_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 256);
  avg_time = call_kernel_4_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 512);
  avg_time = call_kernel_4_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 1024);
  avg_time = call_kernel_4_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 32, 2048);
  avg_time = call_kernel_4_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 1);
  avg_time = call_kernel_4_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 2);
  avg_time = call_kernel_4_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 4);
  avg_time = call_kernel_4_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 8);
  avg_time = call_kernel_4_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 16);
  avg_time = call_kernel_4_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 32);
  avg_time = call_kernel_4_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 64);
  avg_time = call_kernel_4_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 128);
  avg_time = call_kernel_4_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 256);
  avg_time = call_kernel_4_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 512);
  avg_time = call_kernel_4_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 1024);
  avg_time = call_kernel_4_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 64, 2048);
  avg_time = call_kernel_4_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 1);
  avg_time = call_kernel_4_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 2);
  avg_time = call_kernel_4_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 4);
  avg_time = call_kernel_4_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 8);
  avg_time = call_kernel_4_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 16);
  avg_time = call_kernel_4_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 32);
  avg_time = call_kernel_4_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 64);
  avg_time = call_kernel_4_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 128);
  avg_time = call_kernel_4_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 256);
  avg_time = call_kernel_4_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 512);
  avg_time = call_kernel_4_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 1024);
  avg_time = call_kernel_4_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 128, 2048);
  avg_time = call_kernel_4_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 1);
  avg_time = call_kernel_4_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 2);
  avg_time = call_kernel_4_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 4);
  avg_time = call_kernel_4_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 8);
  avg_time = call_kernel_4_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 16);
  avg_time = call_kernel_4_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 32);
  avg_time = call_kernel_4_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 64);
  avg_time = call_kernel_4_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 128);
  avg_time = call_kernel_4_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 256);
  avg_time = call_kernel_4_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 512);
  avg_time = call_kernel_4_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 1024);
  avg_time = call_kernel_4_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 256, 2048);
  avg_time = call_kernel_4_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 1);
  avg_time = call_kernel_4_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 2);
  avg_time = call_kernel_4_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 4);
  avg_time = call_kernel_4_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 8);
  avg_time = call_kernel_4_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 16);
  avg_time = call_kernel_4_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 32);
  avg_time = call_kernel_4_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 64);
  avg_time = call_kernel_4_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 128);
  avg_time = call_kernel_4_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 256);
  avg_time = call_kernel_4_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 512);
  avg_time = call_kernel_4_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 1024);
  avg_time = call_kernel_4_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 512, 2048);
  avg_time = call_kernel_4_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 1);
  avg_time = call_kernel_4_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 2);
  avg_time = call_kernel_4_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 4);
  avg_time = call_kernel_4_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 8);
  avg_time = call_kernel_4_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 16);
  avg_time = call_kernel_4_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 32);
  avg_time = call_kernel_4_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 64);
  avg_time = call_kernel_4_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 128);
  avg_time = call_kernel_4_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 256);
  avg_time = call_kernel_4_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 512);
  avg_time = call_kernel_4_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 1024);
  avg_time = call_kernel_4_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 1024, 2048);
  avg_time = call_kernel_4_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 1);
  avg_time = call_kernel_4_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 2);
  avg_time = call_kernel_4_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 4);
  avg_time = call_kernel_4_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 8);
  avg_time = call_kernel_4_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 16);
  avg_time = call_kernel_4_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 32);
  avg_time = call_kernel_4_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 64);
  avg_time = call_kernel_4_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 128);
  avg_time = call_kernel_4_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 256);
  avg_time = call_kernel_4_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 512);
  avg_time = call_kernel_4_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 1024);
  avg_time = call_kernel_4_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 4, 2048, 2048);
  avg_time = call_kernel_4_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {4, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 1);
  avg_time = call_kernel_8_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 2);
  avg_time = call_kernel_8_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 4);
  avg_time = call_kernel_8_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 8);
  avg_time = call_kernel_8_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 16);
  avg_time = call_kernel_8_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 32);
  avg_time = call_kernel_8_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 64);
  avg_time = call_kernel_8_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 128);
  avg_time = call_kernel_8_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 256);
  avg_time = call_kernel_8_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 512);
  avg_time = call_kernel_8_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 1024);
  avg_time = call_kernel_8_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1, 2048);
  avg_time = call_kernel_8_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 1);
  avg_time = call_kernel_8_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 2);
  avg_time = call_kernel_8_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 4);
  avg_time = call_kernel_8_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 8);
  avg_time = call_kernel_8_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 16);
  avg_time = call_kernel_8_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 32);
  avg_time = call_kernel_8_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 64);
  avg_time = call_kernel_8_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 128);
  avg_time = call_kernel_8_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 256);
  avg_time = call_kernel_8_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 512);
  avg_time = call_kernel_8_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 1024);
  avg_time = call_kernel_8_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2, 2048);
  avg_time = call_kernel_8_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 1);
  avg_time = call_kernel_8_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 2);
  avg_time = call_kernel_8_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 4);
  avg_time = call_kernel_8_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 8);
  avg_time = call_kernel_8_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 16);
  avg_time = call_kernel_8_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 32);
  avg_time = call_kernel_8_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 64);
  avg_time = call_kernel_8_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 128);
  avg_time = call_kernel_8_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 256);
  avg_time = call_kernel_8_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 512);
  avg_time = call_kernel_8_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 1024);
  avg_time = call_kernel_8_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 4, 2048);
  avg_time = call_kernel_8_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 1);
  avg_time = call_kernel_8_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 2);
  avg_time = call_kernel_8_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 4);
  avg_time = call_kernel_8_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 8);
  avg_time = call_kernel_8_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 16);
  avg_time = call_kernel_8_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 32);
  avg_time = call_kernel_8_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 64);
  avg_time = call_kernel_8_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 128);
  avg_time = call_kernel_8_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 256);
  avg_time = call_kernel_8_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 512);
  avg_time = call_kernel_8_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 1024);
  avg_time = call_kernel_8_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 8, 2048);
  avg_time = call_kernel_8_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 1);
  avg_time = call_kernel_8_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 2);
  avg_time = call_kernel_8_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 4);
  avg_time = call_kernel_8_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 8);
  avg_time = call_kernel_8_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 16);
  avg_time = call_kernel_8_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 32);
  avg_time = call_kernel_8_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 64);
  avg_time = call_kernel_8_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 128);
  avg_time = call_kernel_8_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 256);
  avg_time = call_kernel_8_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 512);
  avg_time = call_kernel_8_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 1024);
  avg_time = call_kernel_8_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 16, 2048);
  avg_time = call_kernel_8_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 1);
  avg_time = call_kernel_8_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 2);
  avg_time = call_kernel_8_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 4);
  avg_time = call_kernel_8_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 8);
  avg_time = call_kernel_8_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 16);
  avg_time = call_kernel_8_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 32);
  avg_time = call_kernel_8_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 64);
  avg_time = call_kernel_8_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 128);
  avg_time = call_kernel_8_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 256);
  avg_time = call_kernel_8_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 512);
  avg_time = call_kernel_8_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 1024);
  avg_time = call_kernel_8_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 32, 2048);
  avg_time = call_kernel_8_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 1);
  avg_time = call_kernel_8_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 2);
  avg_time = call_kernel_8_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 4);
  avg_time = call_kernel_8_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 8);
  avg_time = call_kernel_8_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 16);
  avg_time = call_kernel_8_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 32);
  avg_time = call_kernel_8_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 64);
  avg_time = call_kernel_8_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 128);
  avg_time = call_kernel_8_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 256);
  avg_time = call_kernel_8_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 512);
  avg_time = call_kernel_8_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 1024);
  avg_time = call_kernel_8_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 64, 2048);
  avg_time = call_kernel_8_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 1);
  avg_time = call_kernel_8_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 2);
  avg_time = call_kernel_8_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 4);
  avg_time = call_kernel_8_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 8);
  avg_time = call_kernel_8_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 16);
  avg_time = call_kernel_8_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 32);
  avg_time = call_kernel_8_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 64);
  avg_time = call_kernel_8_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 128);
  avg_time = call_kernel_8_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 256);
  avg_time = call_kernel_8_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 512);
  avg_time = call_kernel_8_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 1024);
  avg_time = call_kernel_8_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 128, 2048);
  avg_time = call_kernel_8_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 1);
  avg_time = call_kernel_8_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 2);
  avg_time = call_kernel_8_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 4);
  avg_time = call_kernel_8_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 8);
  avg_time = call_kernel_8_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 16);
  avg_time = call_kernel_8_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 32);
  avg_time = call_kernel_8_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 64);
  avg_time = call_kernel_8_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 128);
  avg_time = call_kernel_8_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 256);
  avg_time = call_kernel_8_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 512);
  avg_time = call_kernel_8_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 1024);
  avg_time = call_kernel_8_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 256, 2048);
  avg_time = call_kernel_8_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 1);
  avg_time = call_kernel_8_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 2);
  avg_time = call_kernel_8_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 4);
  avg_time = call_kernel_8_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 8);
  avg_time = call_kernel_8_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 16);
  avg_time = call_kernel_8_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 32);
  avg_time = call_kernel_8_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 64);
  avg_time = call_kernel_8_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 128);
  avg_time = call_kernel_8_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 256);
  avg_time = call_kernel_8_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 512);
  avg_time = call_kernel_8_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 1024);
  avg_time = call_kernel_8_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 512, 2048);
  avg_time = call_kernel_8_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 1);
  avg_time = call_kernel_8_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 2);
  avg_time = call_kernel_8_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 4);
  avg_time = call_kernel_8_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 8);
  avg_time = call_kernel_8_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 16);
  avg_time = call_kernel_8_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 32);
  avg_time = call_kernel_8_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 64);
  avg_time = call_kernel_8_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 128);
  avg_time = call_kernel_8_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 256);
  avg_time = call_kernel_8_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 512);
  avg_time = call_kernel_8_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 1024);
  avg_time = call_kernel_8_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 1024, 2048);
  avg_time = call_kernel_8_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 1);
  avg_time = call_kernel_8_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 2);
  avg_time = call_kernel_8_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 4);
  avg_time = call_kernel_8_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 8);
  avg_time = call_kernel_8_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 16);
  avg_time = call_kernel_8_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 32);
  avg_time = call_kernel_8_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 64);
  avg_time = call_kernel_8_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 128);
  avg_time = call_kernel_8_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 256);
  avg_time = call_kernel_8_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 512);
  avg_time = call_kernel_8_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 1024);
  avg_time = call_kernel_8_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 8, 2048, 2048);
  avg_time = call_kernel_8_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {8, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 1);
  avg_time = call_kernel_16_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 2);
  avg_time = call_kernel_16_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 4);
  avg_time = call_kernel_16_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 8);
  avg_time = call_kernel_16_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 16);
  avg_time = call_kernel_16_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 32);
  avg_time = call_kernel_16_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 64);
  avg_time = call_kernel_16_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 128);
  avg_time = call_kernel_16_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 256);
  avg_time = call_kernel_16_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 512);
  avg_time = call_kernel_16_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 1024);
  avg_time = call_kernel_16_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1, 2048);
  avg_time = call_kernel_16_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 1);
  avg_time = call_kernel_16_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 2);
  avg_time = call_kernel_16_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 4);
  avg_time = call_kernel_16_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 8);
  avg_time = call_kernel_16_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 16);
  avg_time = call_kernel_16_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 32);
  avg_time = call_kernel_16_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 64);
  avg_time = call_kernel_16_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 128);
  avg_time = call_kernel_16_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 256);
  avg_time = call_kernel_16_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 512);
  avg_time = call_kernel_16_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 1024);
  avg_time = call_kernel_16_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2, 2048);
  avg_time = call_kernel_16_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 1);
  avg_time = call_kernel_16_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 2);
  avg_time = call_kernel_16_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 4);
  avg_time = call_kernel_16_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 8);
  avg_time = call_kernel_16_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 16);
  avg_time = call_kernel_16_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 32);
  avg_time = call_kernel_16_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 64);
  avg_time = call_kernel_16_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 128);
  avg_time = call_kernel_16_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 256);
  avg_time = call_kernel_16_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 512);
  avg_time = call_kernel_16_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 1024);
  avg_time = call_kernel_16_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 4, 2048);
  avg_time = call_kernel_16_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 1);
  avg_time = call_kernel_16_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 2);
  avg_time = call_kernel_16_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 4);
  avg_time = call_kernel_16_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 8);
  avg_time = call_kernel_16_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 16);
  avg_time = call_kernel_16_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 32);
  avg_time = call_kernel_16_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 64);
  avg_time = call_kernel_16_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 128);
  avg_time = call_kernel_16_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 256);
  avg_time = call_kernel_16_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 512);
  avg_time = call_kernel_16_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 1024);
  avg_time = call_kernel_16_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 8, 2048);
  avg_time = call_kernel_16_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 1);
  avg_time = call_kernel_16_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 2);
  avg_time = call_kernel_16_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 4);
  avg_time = call_kernel_16_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 8);
  avg_time = call_kernel_16_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 16);
  avg_time = call_kernel_16_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 32);
  avg_time = call_kernel_16_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 64);
  avg_time = call_kernel_16_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 128);
  avg_time = call_kernel_16_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 256);
  avg_time = call_kernel_16_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 512);
  avg_time = call_kernel_16_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 1024);
  avg_time = call_kernel_16_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 16, 2048);
  avg_time = call_kernel_16_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 1);
  avg_time = call_kernel_16_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 2);
  avg_time = call_kernel_16_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 4);
  avg_time = call_kernel_16_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 8);
  avg_time = call_kernel_16_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 16);
  avg_time = call_kernel_16_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 32);
  avg_time = call_kernel_16_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 64);
  avg_time = call_kernel_16_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 128);
  avg_time = call_kernel_16_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 256);
  avg_time = call_kernel_16_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 512);
  avg_time = call_kernel_16_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 1024);
  avg_time = call_kernel_16_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 32, 2048);
  avg_time = call_kernel_16_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 1);
  avg_time = call_kernel_16_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 2);
  avg_time = call_kernel_16_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 4);
  avg_time = call_kernel_16_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 8);
  avg_time = call_kernel_16_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 16);
  avg_time = call_kernel_16_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 32);
  avg_time = call_kernel_16_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 64);
  avg_time = call_kernel_16_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 128);
  avg_time = call_kernel_16_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 256);
  avg_time = call_kernel_16_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 512);
  avg_time = call_kernel_16_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 1024);
  avg_time = call_kernel_16_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 64, 2048);
  avg_time = call_kernel_16_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 1);
  avg_time = call_kernel_16_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 2);
  avg_time = call_kernel_16_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 4);
  avg_time = call_kernel_16_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 8);
  avg_time = call_kernel_16_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 16);
  avg_time = call_kernel_16_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 32);
  avg_time = call_kernel_16_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 64);
  avg_time = call_kernel_16_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 128);
  avg_time = call_kernel_16_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 256);
  avg_time = call_kernel_16_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 512);
  avg_time = call_kernel_16_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 1024);
  avg_time = call_kernel_16_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 128, 2048);
  avg_time = call_kernel_16_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 1);
  avg_time = call_kernel_16_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 2);
  avg_time = call_kernel_16_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 4);
  avg_time = call_kernel_16_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 8);
  avg_time = call_kernel_16_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 16);
  avg_time = call_kernel_16_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 32);
  avg_time = call_kernel_16_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 64);
  avg_time = call_kernel_16_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 128);
  avg_time = call_kernel_16_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 256);
  avg_time = call_kernel_16_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 512);
  avg_time = call_kernel_16_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 1024);
  avg_time = call_kernel_16_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 256, 2048);
  avg_time = call_kernel_16_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 1);
  avg_time = call_kernel_16_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 2);
  avg_time = call_kernel_16_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 4);
  avg_time = call_kernel_16_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 8);
  avg_time = call_kernel_16_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 16);
  avg_time = call_kernel_16_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 32);
  avg_time = call_kernel_16_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 64);
  avg_time = call_kernel_16_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 128);
  avg_time = call_kernel_16_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 256);
  avg_time = call_kernel_16_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 512);
  avg_time = call_kernel_16_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 1024);
  avg_time = call_kernel_16_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 512, 2048);
  avg_time = call_kernel_16_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 1);
  avg_time = call_kernel_16_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 2);
  avg_time = call_kernel_16_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 4);
  avg_time = call_kernel_16_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 8);
  avg_time = call_kernel_16_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 16);
  avg_time = call_kernel_16_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 32);
  avg_time = call_kernel_16_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 64);
  avg_time = call_kernel_16_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 128);
  avg_time = call_kernel_16_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 256);
  avg_time = call_kernel_16_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 512);
  avg_time = call_kernel_16_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 1024);
  avg_time = call_kernel_16_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 1024, 2048);
  avg_time = call_kernel_16_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 1);
  avg_time = call_kernel_16_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 2);
  avg_time = call_kernel_16_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 4);
  avg_time = call_kernel_16_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 8);
  avg_time = call_kernel_16_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 16);
  avg_time = call_kernel_16_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 32);
  avg_time = call_kernel_16_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 64);
  avg_time = call_kernel_16_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 128);
  avg_time = call_kernel_16_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 256);
  avg_time = call_kernel_16_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 512);
  avg_time = call_kernel_16_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 1024);
  avg_time = call_kernel_16_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 16, 2048, 2048);
  avg_time = call_kernel_16_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {16, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 1);
  avg_time = call_kernel_32_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 2);
  avg_time = call_kernel_32_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 4);
  avg_time = call_kernel_32_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 8);
  avg_time = call_kernel_32_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 16);
  avg_time = call_kernel_32_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 32);
  avg_time = call_kernel_32_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 64);
  avg_time = call_kernel_32_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 128);
  avg_time = call_kernel_32_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 256);
  avg_time = call_kernel_32_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 512);
  avg_time = call_kernel_32_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 1024);
  avg_time = call_kernel_32_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1, 2048);
  avg_time = call_kernel_32_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 1);
  avg_time = call_kernel_32_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 2);
  avg_time = call_kernel_32_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 4);
  avg_time = call_kernel_32_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 8);
  avg_time = call_kernel_32_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 16);
  avg_time = call_kernel_32_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 32);
  avg_time = call_kernel_32_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 64);
  avg_time = call_kernel_32_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 128);
  avg_time = call_kernel_32_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 256);
  avg_time = call_kernel_32_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 512);
  avg_time = call_kernel_32_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 1024);
  avg_time = call_kernel_32_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2, 2048);
  avg_time = call_kernel_32_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 1);
  avg_time = call_kernel_32_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 2);
  avg_time = call_kernel_32_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 4);
  avg_time = call_kernel_32_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 8);
  avg_time = call_kernel_32_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 16);
  avg_time = call_kernel_32_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 32);
  avg_time = call_kernel_32_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 64);
  avg_time = call_kernel_32_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 128);
  avg_time = call_kernel_32_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 256);
  avg_time = call_kernel_32_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 512);
  avg_time = call_kernel_32_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 1024);
  avg_time = call_kernel_32_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 4, 2048);
  avg_time = call_kernel_32_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 1);
  avg_time = call_kernel_32_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 2);
  avg_time = call_kernel_32_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 4);
  avg_time = call_kernel_32_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 8);
  avg_time = call_kernel_32_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 16);
  avg_time = call_kernel_32_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 32);
  avg_time = call_kernel_32_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 64);
  avg_time = call_kernel_32_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 128);
  avg_time = call_kernel_32_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 256);
  avg_time = call_kernel_32_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 512);
  avg_time = call_kernel_32_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 1024);
  avg_time = call_kernel_32_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 8, 2048);
  avg_time = call_kernel_32_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 1);
  avg_time = call_kernel_32_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 2);
  avg_time = call_kernel_32_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 4);
  avg_time = call_kernel_32_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 8);
  avg_time = call_kernel_32_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 16);
  avg_time = call_kernel_32_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 32);
  avg_time = call_kernel_32_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 64);
  avg_time = call_kernel_32_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 128);
  avg_time = call_kernel_32_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 256);
  avg_time = call_kernel_32_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 512);
  avg_time = call_kernel_32_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 1024);
  avg_time = call_kernel_32_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 16, 2048);
  avg_time = call_kernel_32_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 1);
  avg_time = call_kernel_32_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 2);
  avg_time = call_kernel_32_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 4);
  avg_time = call_kernel_32_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 8);
  avg_time = call_kernel_32_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 16);
  avg_time = call_kernel_32_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 32);
  avg_time = call_kernel_32_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 64);
  avg_time = call_kernel_32_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 128);
  avg_time = call_kernel_32_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 256);
  avg_time = call_kernel_32_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 512);
  avg_time = call_kernel_32_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 1024);
  avg_time = call_kernel_32_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 32, 2048);
  avg_time = call_kernel_32_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 1);
  avg_time = call_kernel_32_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 2);
  avg_time = call_kernel_32_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 4);
  avg_time = call_kernel_32_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 8);
  avg_time = call_kernel_32_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 16);
  avg_time = call_kernel_32_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 32);
  avg_time = call_kernel_32_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 64);
  avg_time = call_kernel_32_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 128);
  avg_time = call_kernel_32_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 256);
  avg_time = call_kernel_32_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 512);
  avg_time = call_kernel_32_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 1024);
  avg_time = call_kernel_32_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 64, 2048);
  avg_time = call_kernel_32_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 1);
  avg_time = call_kernel_32_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 2);
  avg_time = call_kernel_32_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 4);
  avg_time = call_kernel_32_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 8);
  avg_time = call_kernel_32_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 16);
  avg_time = call_kernel_32_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 32);
  avg_time = call_kernel_32_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 64);
  avg_time = call_kernel_32_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 128);
  avg_time = call_kernel_32_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 256);
  avg_time = call_kernel_32_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 512);
  avg_time = call_kernel_32_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 1024);
  avg_time = call_kernel_32_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 128, 2048);
  avg_time = call_kernel_32_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 1);
  avg_time = call_kernel_32_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 2);
  avg_time = call_kernel_32_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 4);
  avg_time = call_kernel_32_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 8);
  avg_time = call_kernel_32_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 16);
  avg_time = call_kernel_32_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 32);
  avg_time = call_kernel_32_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 64);
  avg_time = call_kernel_32_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 128);
  avg_time = call_kernel_32_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 256);
  avg_time = call_kernel_32_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 512);
  avg_time = call_kernel_32_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 1024);
  avg_time = call_kernel_32_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 256, 2048);
  avg_time = call_kernel_32_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 1);
  avg_time = call_kernel_32_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 2);
  avg_time = call_kernel_32_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 4);
  avg_time = call_kernel_32_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 8);
  avg_time = call_kernel_32_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 16);
  avg_time = call_kernel_32_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 32);
  avg_time = call_kernel_32_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 64);
  avg_time = call_kernel_32_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 128);
  avg_time = call_kernel_32_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 256);
  avg_time = call_kernel_32_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 512);
  avg_time = call_kernel_32_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 1024);
  avg_time = call_kernel_32_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 512, 2048);
  avg_time = call_kernel_32_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 1);
  avg_time = call_kernel_32_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 2);
  avg_time = call_kernel_32_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 4);
  avg_time = call_kernel_32_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 8);
  avg_time = call_kernel_32_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 16);
  avg_time = call_kernel_32_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 32);
  avg_time = call_kernel_32_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 64);
  avg_time = call_kernel_32_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 128);
  avg_time = call_kernel_32_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 256);
  avg_time = call_kernel_32_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 512);
  avg_time = call_kernel_32_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 1024);
  avg_time = call_kernel_32_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 1024, 2048);
  avg_time = call_kernel_32_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 1);
  avg_time = call_kernel_32_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 2);
  avg_time = call_kernel_32_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 4);
  avg_time = call_kernel_32_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 8);
  avg_time = call_kernel_32_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 16);
  avg_time = call_kernel_32_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 32);
  avg_time = call_kernel_32_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 64);
  avg_time = call_kernel_32_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 128);
  avg_time = call_kernel_32_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 256);
  avg_time = call_kernel_32_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 512);
  avg_time = call_kernel_32_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 1024);
  avg_time = call_kernel_32_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 32, 2048, 2048);
  avg_time = call_kernel_32_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {32, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 1);
  avg_time = call_kernel_64_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 2);
  avg_time = call_kernel_64_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 4);
  avg_time = call_kernel_64_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 8);
  avg_time = call_kernel_64_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 16);
  avg_time = call_kernel_64_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 32);
  avg_time = call_kernel_64_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 64);
  avg_time = call_kernel_64_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 128);
  avg_time = call_kernel_64_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 256);
  avg_time = call_kernel_64_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 512);
  avg_time = call_kernel_64_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 1024);
  avg_time = call_kernel_64_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1, 2048);
  avg_time = call_kernel_64_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 1);
  avg_time = call_kernel_64_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 2);
  avg_time = call_kernel_64_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 4);
  avg_time = call_kernel_64_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 8);
  avg_time = call_kernel_64_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 16);
  avg_time = call_kernel_64_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 32);
  avg_time = call_kernel_64_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 64);
  avg_time = call_kernel_64_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 128);
  avg_time = call_kernel_64_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 256);
  avg_time = call_kernel_64_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 512);
  avg_time = call_kernel_64_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 1024);
  avg_time = call_kernel_64_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2, 2048);
  avg_time = call_kernel_64_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 1);
  avg_time = call_kernel_64_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 2);
  avg_time = call_kernel_64_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 4);
  avg_time = call_kernel_64_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 8);
  avg_time = call_kernel_64_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 16);
  avg_time = call_kernel_64_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 32);
  avg_time = call_kernel_64_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 64);
  avg_time = call_kernel_64_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 128);
  avg_time = call_kernel_64_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 256);
  avg_time = call_kernel_64_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 512);
  avg_time = call_kernel_64_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 1024);
  avg_time = call_kernel_64_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 4, 2048);
  avg_time = call_kernel_64_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 1);
  avg_time = call_kernel_64_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 2);
  avg_time = call_kernel_64_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 4);
  avg_time = call_kernel_64_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 8);
  avg_time = call_kernel_64_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 16);
  avg_time = call_kernel_64_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 32);
  avg_time = call_kernel_64_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 64);
  avg_time = call_kernel_64_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 128);
  avg_time = call_kernel_64_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 256);
  avg_time = call_kernel_64_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 512);
  avg_time = call_kernel_64_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 1024);
  avg_time = call_kernel_64_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 8, 2048);
  avg_time = call_kernel_64_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 1);
  avg_time = call_kernel_64_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 2);
  avg_time = call_kernel_64_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 4);
  avg_time = call_kernel_64_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 8);
  avg_time = call_kernel_64_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 16);
  avg_time = call_kernel_64_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 32);
  avg_time = call_kernel_64_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 64);
  avg_time = call_kernel_64_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 128);
  avg_time = call_kernel_64_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 256);
  avg_time = call_kernel_64_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 512);
  avg_time = call_kernel_64_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 1024);
  avg_time = call_kernel_64_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 16, 2048);
  avg_time = call_kernel_64_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 1);
  avg_time = call_kernel_64_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 2);
  avg_time = call_kernel_64_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 4);
  avg_time = call_kernel_64_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 8);
  avg_time = call_kernel_64_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 16);
  avg_time = call_kernel_64_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 32);
  avg_time = call_kernel_64_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 64);
  avg_time = call_kernel_64_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 128);
  avg_time = call_kernel_64_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 256);
  avg_time = call_kernel_64_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 512);
  avg_time = call_kernel_64_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 1024);
  avg_time = call_kernel_64_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 32, 2048);
  avg_time = call_kernel_64_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 1);
  avg_time = call_kernel_64_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 2);
  avg_time = call_kernel_64_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 4);
  avg_time = call_kernel_64_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 8);
  avg_time = call_kernel_64_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 16);
  avg_time = call_kernel_64_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 32);
  avg_time = call_kernel_64_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 64);
  avg_time = call_kernel_64_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 128);
  avg_time = call_kernel_64_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 256);
  avg_time = call_kernel_64_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 512);
  avg_time = call_kernel_64_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 1024);
  avg_time = call_kernel_64_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 64, 2048);
  avg_time = call_kernel_64_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 1);
  avg_time = call_kernel_64_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 2);
  avg_time = call_kernel_64_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 4);
  avg_time = call_kernel_64_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 8);
  avg_time = call_kernel_64_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 16);
  avg_time = call_kernel_64_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 32);
  avg_time = call_kernel_64_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 64);
  avg_time = call_kernel_64_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 128);
  avg_time = call_kernel_64_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 256);
  avg_time = call_kernel_64_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 512);
  avg_time = call_kernel_64_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 1024);
  avg_time = call_kernel_64_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 128, 2048);
  avg_time = call_kernel_64_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 1);
  avg_time = call_kernel_64_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 2);
  avg_time = call_kernel_64_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 4);
  avg_time = call_kernel_64_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 8);
  avg_time = call_kernel_64_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 16);
  avg_time = call_kernel_64_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 32);
  avg_time = call_kernel_64_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 64);
  avg_time = call_kernel_64_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 128);
  avg_time = call_kernel_64_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 256);
  avg_time = call_kernel_64_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 512);
  avg_time = call_kernel_64_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 1024);
  avg_time = call_kernel_64_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 256, 2048);
  avg_time = call_kernel_64_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 1);
  avg_time = call_kernel_64_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 2);
  avg_time = call_kernel_64_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 4);
  avg_time = call_kernel_64_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 8);
  avg_time = call_kernel_64_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 16);
  avg_time = call_kernel_64_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 32);
  avg_time = call_kernel_64_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 64);
  avg_time = call_kernel_64_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 128);
  avg_time = call_kernel_64_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 256);
  avg_time = call_kernel_64_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 512);
  avg_time = call_kernel_64_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 1024);
  avg_time = call_kernel_64_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 512, 2048);
  avg_time = call_kernel_64_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 1);
  avg_time = call_kernel_64_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 2);
  avg_time = call_kernel_64_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 4);
  avg_time = call_kernel_64_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 8);
  avg_time = call_kernel_64_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 16);
  avg_time = call_kernel_64_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 32);
  avg_time = call_kernel_64_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 64);
  avg_time = call_kernel_64_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 128);
  avg_time = call_kernel_64_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 256);
  avg_time = call_kernel_64_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 512);
  avg_time = call_kernel_64_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 1024);
  avg_time = call_kernel_64_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 1024, 2048);
  avg_time = call_kernel_64_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 1);
  avg_time = call_kernel_64_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 2);
  avg_time = call_kernel_64_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 4);
  avg_time = call_kernel_64_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 8);
  avg_time = call_kernel_64_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 16);
  avg_time = call_kernel_64_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 32);
  avg_time = call_kernel_64_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 64);
  avg_time = call_kernel_64_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 128);
  avg_time = call_kernel_64_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 256);
  avg_time = call_kernel_64_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 512);
  avg_time = call_kernel_64_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 1024);
  avg_time = call_kernel_64_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 64, 2048, 2048);
  avg_time = call_kernel_64_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {64, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 1);
  avg_time = call_kernel_128_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 2);
  avg_time = call_kernel_128_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 4);
  avg_time = call_kernel_128_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 8);
  avg_time = call_kernel_128_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 16);
  avg_time = call_kernel_128_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 32);
  avg_time = call_kernel_128_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 64);
  avg_time = call_kernel_128_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 128);
  avg_time = call_kernel_128_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 256);
  avg_time = call_kernel_128_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 512);
  avg_time = call_kernel_128_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 1024);
  avg_time = call_kernel_128_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1, 2048);
  avg_time = call_kernel_128_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 1);
  avg_time = call_kernel_128_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 2);
  avg_time = call_kernel_128_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 4);
  avg_time = call_kernel_128_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 8);
  avg_time = call_kernel_128_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 16);
  avg_time = call_kernel_128_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 32);
  avg_time = call_kernel_128_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 64);
  avg_time = call_kernel_128_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 128);
  avg_time = call_kernel_128_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 256);
  avg_time = call_kernel_128_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 512);
  avg_time = call_kernel_128_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 1024);
  avg_time = call_kernel_128_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2, 2048);
  avg_time = call_kernel_128_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 1);
  avg_time = call_kernel_128_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 2);
  avg_time = call_kernel_128_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 4);
  avg_time = call_kernel_128_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 8);
  avg_time = call_kernel_128_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 16);
  avg_time = call_kernel_128_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 32);
  avg_time = call_kernel_128_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 64);
  avg_time = call_kernel_128_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 128);
  avg_time = call_kernel_128_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 256);
  avg_time = call_kernel_128_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 512);
  avg_time = call_kernel_128_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 1024);
  avg_time = call_kernel_128_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 4, 2048);
  avg_time = call_kernel_128_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 1);
  avg_time = call_kernel_128_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 2);
  avg_time = call_kernel_128_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 4);
  avg_time = call_kernel_128_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 8);
  avg_time = call_kernel_128_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 16);
  avg_time = call_kernel_128_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 32);
  avg_time = call_kernel_128_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 64);
  avg_time = call_kernel_128_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 128);
  avg_time = call_kernel_128_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 256);
  avg_time = call_kernel_128_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 512);
  avg_time = call_kernel_128_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 1024);
  avg_time = call_kernel_128_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 8, 2048);
  avg_time = call_kernel_128_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 1);
  avg_time = call_kernel_128_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 2);
  avg_time = call_kernel_128_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 4);
  avg_time = call_kernel_128_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 8);
  avg_time = call_kernel_128_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 16);
  avg_time = call_kernel_128_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 32);
  avg_time = call_kernel_128_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 64);
  avg_time = call_kernel_128_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 128);
  avg_time = call_kernel_128_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 256);
  avg_time = call_kernel_128_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 512);
  avg_time = call_kernel_128_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 1024);
  avg_time = call_kernel_128_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 16, 2048);
  avg_time = call_kernel_128_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 1);
  avg_time = call_kernel_128_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 2);
  avg_time = call_kernel_128_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 4);
  avg_time = call_kernel_128_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 8);
  avg_time = call_kernel_128_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 16);
  avg_time = call_kernel_128_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 32);
  avg_time = call_kernel_128_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 64);
  avg_time = call_kernel_128_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 128);
  avg_time = call_kernel_128_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 256);
  avg_time = call_kernel_128_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 512);
  avg_time = call_kernel_128_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 1024);
  avg_time = call_kernel_128_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 32, 2048);
  avg_time = call_kernel_128_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 1);
  avg_time = call_kernel_128_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 2);
  avg_time = call_kernel_128_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 4);
  avg_time = call_kernel_128_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 8);
  avg_time = call_kernel_128_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 16);
  avg_time = call_kernel_128_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 32);
  avg_time = call_kernel_128_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 64);
  avg_time = call_kernel_128_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 128);
  avg_time = call_kernel_128_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 256);
  avg_time = call_kernel_128_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 512);
  avg_time = call_kernel_128_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 1024);
  avg_time = call_kernel_128_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 64, 2048);
  avg_time = call_kernel_128_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 1);
  avg_time = call_kernel_128_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 2);
  avg_time = call_kernel_128_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 4);
  avg_time = call_kernel_128_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 8);
  avg_time = call_kernel_128_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 16);
  avg_time = call_kernel_128_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 32);
  avg_time = call_kernel_128_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 64);
  avg_time = call_kernel_128_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 128);
  avg_time = call_kernel_128_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 256);
  avg_time = call_kernel_128_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 512);
  avg_time = call_kernel_128_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 1024);
  avg_time = call_kernel_128_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 128, 2048);
  avg_time = call_kernel_128_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 1);
  avg_time = call_kernel_128_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 2);
  avg_time = call_kernel_128_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 4);
  avg_time = call_kernel_128_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 8);
  avg_time = call_kernel_128_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 16);
  avg_time = call_kernel_128_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 32);
  avg_time = call_kernel_128_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 64);
  avg_time = call_kernel_128_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 128);
  avg_time = call_kernel_128_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 256);
  avg_time = call_kernel_128_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 512);
  avg_time = call_kernel_128_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 1024);
  avg_time = call_kernel_128_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 256, 2048);
  avg_time = call_kernel_128_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 1);
  avg_time = call_kernel_128_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 2);
  avg_time = call_kernel_128_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 4);
  avg_time = call_kernel_128_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 8);
  avg_time = call_kernel_128_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 16);
  avg_time = call_kernel_128_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 32);
  avg_time = call_kernel_128_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 64);
  avg_time = call_kernel_128_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 128);
  avg_time = call_kernel_128_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 256);
  avg_time = call_kernel_128_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 512);
  avg_time = call_kernel_128_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 1024);
  avg_time = call_kernel_128_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 512, 2048);
  avg_time = call_kernel_128_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 1);
  avg_time = call_kernel_128_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 2);
  avg_time = call_kernel_128_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 4);
  avg_time = call_kernel_128_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 8);
  avg_time = call_kernel_128_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 16);
  avg_time = call_kernel_128_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 32);
  avg_time = call_kernel_128_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 64);
  avg_time = call_kernel_128_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 128);
  avg_time = call_kernel_128_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 256);
  avg_time = call_kernel_128_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 512);
  avg_time = call_kernel_128_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 1024);
  avg_time = call_kernel_128_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 1024, 2048);
  avg_time = call_kernel_128_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 1);
  avg_time = call_kernel_128_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 2);
  avg_time = call_kernel_128_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 4);
  avg_time = call_kernel_128_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 8);
  avg_time = call_kernel_128_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 16);
  avg_time = call_kernel_128_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 32);
  avg_time = call_kernel_128_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 64);
  avg_time = call_kernel_128_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 128);
  avg_time = call_kernel_128_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 256);
  avg_time = call_kernel_128_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 512);
  avg_time = call_kernel_128_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 1024);
  avg_time = call_kernel_128_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 128, 2048, 2048);
  avg_time = call_kernel_128_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {128, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 1);
  avg_time = call_kernel_256_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 2);
  avg_time = call_kernel_256_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 4);
  avg_time = call_kernel_256_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 8);
  avg_time = call_kernel_256_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 16);
  avg_time = call_kernel_256_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 32);
  avg_time = call_kernel_256_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 64);
  avg_time = call_kernel_256_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 128);
  avg_time = call_kernel_256_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 256);
  avg_time = call_kernel_256_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 512);
  avg_time = call_kernel_256_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 1024);
  avg_time = call_kernel_256_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1, 2048);
  avg_time = call_kernel_256_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 1);
  avg_time = call_kernel_256_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 2);
  avg_time = call_kernel_256_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 4);
  avg_time = call_kernel_256_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 8);
  avg_time = call_kernel_256_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 16);
  avg_time = call_kernel_256_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 32);
  avg_time = call_kernel_256_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 64);
  avg_time = call_kernel_256_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 128);
  avg_time = call_kernel_256_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 256);
  avg_time = call_kernel_256_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 512);
  avg_time = call_kernel_256_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 1024);
  avg_time = call_kernel_256_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2, 2048);
  avg_time = call_kernel_256_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 1);
  avg_time = call_kernel_256_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 2);
  avg_time = call_kernel_256_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 4);
  avg_time = call_kernel_256_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 8);
  avg_time = call_kernel_256_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 16);
  avg_time = call_kernel_256_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 32);
  avg_time = call_kernel_256_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 64);
  avg_time = call_kernel_256_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 128);
  avg_time = call_kernel_256_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 256);
  avg_time = call_kernel_256_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 512);
  avg_time = call_kernel_256_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 1024);
  avg_time = call_kernel_256_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 4, 2048);
  avg_time = call_kernel_256_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 1);
  avg_time = call_kernel_256_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 2);
  avg_time = call_kernel_256_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 4);
  avg_time = call_kernel_256_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 8);
  avg_time = call_kernel_256_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 16);
  avg_time = call_kernel_256_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 32);
  avg_time = call_kernel_256_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 64);
  avg_time = call_kernel_256_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 128);
  avg_time = call_kernel_256_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 256);
  avg_time = call_kernel_256_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 512);
  avg_time = call_kernel_256_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 1024);
  avg_time = call_kernel_256_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 8, 2048);
  avg_time = call_kernel_256_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 1);
  avg_time = call_kernel_256_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 2);
  avg_time = call_kernel_256_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 4);
  avg_time = call_kernel_256_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 8);
  avg_time = call_kernel_256_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 16);
  avg_time = call_kernel_256_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 32);
  avg_time = call_kernel_256_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 64);
  avg_time = call_kernel_256_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 128);
  avg_time = call_kernel_256_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 256);
  avg_time = call_kernel_256_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 512);
  avg_time = call_kernel_256_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 1024);
  avg_time = call_kernel_256_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 16, 2048);
  avg_time = call_kernel_256_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 1);
  avg_time = call_kernel_256_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 2);
  avg_time = call_kernel_256_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 4);
  avg_time = call_kernel_256_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 8);
  avg_time = call_kernel_256_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 16);
  avg_time = call_kernel_256_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 32);
  avg_time = call_kernel_256_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 64);
  avg_time = call_kernel_256_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 128);
  avg_time = call_kernel_256_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 256);
  avg_time = call_kernel_256_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 512);
  avg_time = call_kernel_256_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 1024);
  avg_time = call_kernel_256_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 32, 2048);
  avg_time = call_kernel_256_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 1);
  avg_time = call_kernel_256_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 2);
  avg_time = call_kernel_256_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 4);
  avg_time = call_kernel_256_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 8);
  avg_time = call_kernel_256_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 16);
  avg_time = call_kernel_256_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 32);
  avg_time = call_kernel_256_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 64);
  avg_time = call_kernel_256_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 128);
  avg_time = call_kernel_256_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 256);
  avg_time = call_kernel_256_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 512);
  avg_time = call_kernel_256_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 1024);
  avg_time = call_kernel_256_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 64, 2048);
  avg_time = call_kernel_256_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 1);
  avg_time = call_kernel_256_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 2);
  avg_time = call_kernel_256_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 4);
  avg_time = call_kernel_256_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 8);
  avg_time = call_kernel_256_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 16);
  avg_time = call_kernel_256_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 32);
  avg_time = call_kernel_256_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 64);
  avg_time = call_kernel_256_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 128);
  avg_time = call_kernel_256_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 256);
  avg_time = call_kernel_256_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 512);
  avg_time = call_kernel_256_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 1024);
  avg_time = call_kernel_256_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 128, 2048);
  avg_time = call_kernel_256_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 1);
  avg_time = call_kernel_256_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 2);
  avg_time = call_kernel_256_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 4);
  avg_time = call_kernel_256_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 8);
  avg_time = call_kernel_256_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 16);
  avg_time = call_kernel_256_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 32);
  avg_time = call_kernel_256_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 64);
  avg_time = call_kernel_256_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 128);
  avg_time = call_kernel_256_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 256);
  avg_time = call_kernel_256_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 512);
  avg_time = call_kernel_256_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 1024);
  avg_time = call_kernel_256_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 256, 2048);
  avg_time = call_kernel_256_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 1);
  avg_time = call_kernel_256_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 2);
  avg_time = call_kernel_256_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 4);
  avg_time = call_kernel_256_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 8);
  avg_time = call_kernel_256_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 16);
  avg_time = call_kernel_256_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 32);
  avg_time = call_kernel_256_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 64);
  avg_time = call_kernel_256_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 128);
  avg_time = call_kernel_256_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 256);
  avg_time = call_kernel_256_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 512);
  avg_time = call_kernel_256_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 1024);
  avg_time = call_kernel_256_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 512, 2048);
  avg_time = call_kernel_256_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 1);
  avg_time = call_kernel_256_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 2);
  avg_time = call_kernel_256_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 4);
  avg_time = call_kernel_256_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 8);
  avg_time = call_kernel_256_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 16);
  avg_time = call_kernel_256_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 32);
  avg_time = call_kernel_256_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 64);
  avg_time = call_kernel_256_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 128);
  avg_time = call_kernel_256_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 256);
  avg_time = call_kernel_256_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 512);
  avg_time = call_kernel_256_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 1024);
  avg_time = call_kernel_256_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 1024, 2048);
  avg_time = call_kernel_256_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 1);
  avg_time = call_kernel_256_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 2);
  avg_time = call_kernel_256_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 4);
  avg_time = call_kernel_256_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 8);
  avg_time = call_kernel_256_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 16);
  avg_time = call_kernel_256_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 32);
  avg_time = call_kernel_256_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 64);
  avg_time = call_kernel_256_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 128);
  avg_time = call_kernel_256_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 256);
  avg_time = call_kernel_256_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 512);
  avg_time = call_kernel_256_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 1024);
  avg_time = call_kernel_256_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 256, 2048, 2048);
  avg_time = call_kernel_256_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {256, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 1);
  avg_time = call_kernel_512_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 2);
  avg_time = call_kernel_512_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 4);
  avg_time = call_kernel_512_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 8);
  avg_time = call_kernel_512_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 16);
  avg_time = call_kernel_512_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 32);
  avg_time = call_kernel_512_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 64);
  avg_time = call_kernel_512_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 128);
  avg_time = call_kernel_512_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 256);
  avg_time = call_kernel_512_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 512);
  avg_time = call_kernel_512_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 1024);
  avg_time = call_kernel_512_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1, 2048);
  avg_time = call_kernel_512_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 1);
  avg_time = call_kernel_512_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 2);
  avg_time = call_kernel_512_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 4);
  avg_time = call_kernel_512_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 8);
  avg_time = call_kernel_512_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 16);
  avg_time = call_kernel_512_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 32);
  avg_time = call_kernel_512_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 64);
  avg_time = call_kernel_512_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 128);
  avg_time = call_kernel_512_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 256);
  avg_time = call_kernel_512_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 512);
  avg_time = call_kernel_512_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 1024);
  avg_time = call_kernel_512_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2, 2048);
  avg_time = call_kernel_512_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 1);
  avg_time = call_kernel_512_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 2);
  avg_time = call_kernel_512_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 4);
  avg_time = call_kernel_512_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 8);
  avg_time = call_kernel_512_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 16);
  avg_time = call_kernel_512_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 32);
  avg_time = call_kernel_512_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 64);
  avg_time = call_kernel_512_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 128);
  avg_time = call_kernel_512_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 256);
  avg_time = call_kernel_512_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 512);
  avg_time = call_kernel_512_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 1024);
  avg_time = call_kernel_512_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 4, 2048);
  avg_time = call_kernel_512_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 1);
  avg_time = call_kernel_512_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 2);
  avg_time = call_kernel_512_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 4);
  avg_time = call_kernel_512_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 8);
  avg_time = call_kernel_512_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 16);
  avg_time = call_kernel_512_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 32);
  avg_time = call_kernel_512_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 64);
  avg_time = call_kernel_512_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 128);
  avg_time = call_kernel_512_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 256);
  avg_time = call_kernel_512_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 512);
  avg_time = call_kernel_512_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 1024);
  avg_time = call_kernel_512_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 8, 2048);
  avg_time = call_kernel_512_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 1);
  avg_time = call_kernel_512_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 2);
  avg_time = call_kernel_512_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 4);
  avg_time = call_kernel_512_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 8);
  avg_time = call_kernel_512_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 16);
  avg_time = call_kernel_512_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 32);
  avg_time = call_kernel_512_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 64);
  avg_time = call_kernel_512_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 128);
  avg_time = call_kernel_512_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 256);
  avg_time = call_kernel_512_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 512);
  avg_time = call_kernel_512_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 1024);
  avg_time = call_kernel_512_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 16, 2048);
  avg_time = call_kernel_512_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 1);
  avg_time = call_kernel_512_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 2);
  avg_time = call_kernel_512_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 4);
  avg_time = call_kernel_512_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 8);
  avg_time = call_kernel_512_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 16);
  avg_time = call_kernel_512_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 32);
  avg_time = call_kernel_512_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 64);
  avg_time = call_kernel_512_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 128);
  avg_time = call_kernel_512_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 256);
  avg_time = call_kernel_512_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 512);
  avg_time = call_kernel_512_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 1024);
  avg_time = call_kernel_512_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 32, 2048);
  avg_time = call_kernel_512_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 1);
  avg_time = call_kernel_512_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 2);
  avg_time = call_kernel_512_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 4);
  avg_time = call_kernel_512_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 8);
  avg_time = call_kernel_512_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 16);
  avg_time = call_kernel_512_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 32);
  avg_time = call_kernel_512_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 64);
  avg_time = call_kernel_512_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 128);
  avg_time = call_kernel_512_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 256);
  avg_time = call_kernel_512_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 512);
  avg_time = call_kernel_512_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 1024);
  avg_time = call_kernel_512_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 64, 2048);
  avg_time = call_kernel_512_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 1);
  avg_time = call_kernel_512_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 2);
  avg_time = call_kernel_512_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 4);
  avg_time = call_kernel_512_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 8);
  avg_time = call_kernel_512_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 16);
  avg_time = call_kernel_512_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 32);
  avg_time = call_kernel_512_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 64);
  avg_time = call_kernel_512_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 128);
  avg_time = call_kernel_512_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 256);
  avg_time = call_kernel_512_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 512);
  avg_time = call_kernel_512_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 1024);
  avg_time = call_kernel_512_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 128, 2048);
  avg_time = call_kernel_512_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 1);
  avg_time = call_kernel_512_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 2);
  avg_time = call_kernel_512_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 4);
  avg_time = call_kernel_512_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 8);
  avg_time = call_kernel_512_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 16);
  avg_time = call_kernel_512_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 32);
  avg_time = call_kernel_512_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 64);
  avg_time = call_kernel_512_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 128);
  avg_time = call_kernel_512_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 256);
  avg_time = call_kernel_512_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 512);
  avg_time = call_kernel_512_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 1024);
  avg_time = call_kernel_512_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 256, 2048);
  avg_time = call_kernel_512_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 1);
  avg_time = call_kernel_512_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 2);
  avg_time = call_kernel_512_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 4);
  avg_time = call_kernel_512_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 8);
  avg_time = call_kernel_512_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 16);
  avg_time = call_kernel_512_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 32);
  avg_time = call_kernel_512_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 64);
  avg_time = call_kernel_512_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 128);
  avg_time = call_kernel_512_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 256);
  avg_time = call_kernel_512_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 512);
  avg_time = call_kernel_512_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 1024);
  avg_time = call_kernel_512_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 512, 2048);
  avg_time = call_kernel_512_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 1);
  avg_time = call_kernel_512_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 2);
  avg_time = call_kernel_512_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 4);
  avg_time = call_kernel_512_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 8);
  avg_time = call_kernel_512_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 16);
  avg_time = call_kernel_512_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 32);
  avg_time = call_kernel_512_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 64);
  avg_time = call_kernel_512_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 128);
  avg_time = call_kernel_512_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 256);
  avg_time = call_kernel_512_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 512);
  avg_time = call_kernel_512_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 1024);
  avg_time = call_kernel_512_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 1024, 2048);
  avg_time = call_kernel_512_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 1);
  avg_time = call_kernel_512_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 2);
  avg_time = call_kernel_512_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 4);
  avg_time = call_kernel_512_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 8);
  avg_time = call_kernel_512_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 16);
  avg_time = call_kernel_512_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 32);
  avg_time = call_kernel_512_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 64);
  avg_time = call_kernel_512_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 128);
  avg_time = call_kernel_512_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 256);
  avg_time = call_kernel_512_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 512);
  avg_time = call_kernel_512_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 1024);
  avg_time = call_kernel_512_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 512, 2048, 2048);
  avg_time = call_kernel_512_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {512, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 1);
  avg_time = call_kernel_1024_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 2);
  avg_time = call_kernel_1024_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 4);
  avg_time = call_kernel_1024_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 8);
  avg_time = call_kernel_1024_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 16);
  avg_time = call_kernel_1024_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 32);
  avg_time = call_kernel_1024_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 64);
  avg_time = call_kernel_1024_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 128);
  avg_time = call_kernel_1024_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 256);
  avg_time = call_kernel_1024_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 512);
  avg_time = call_kernel_1024_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 1024);
  avg_time = call_kernel_1024_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1, 2048);
  avg_time = call_kernel_1024_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 1);
  avg_time = call_kernel_1024_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 2);
  avg_time = call_kernel_1024_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 4);
  avg_time = call_kernel_1024_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 8);
  avg_time = call_kernel_1024_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 16);
  avg_time = call_kernel_1024_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 32);
  avg_time = call_kernel_1024_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 64);
  avg_time = call_kernel_1024_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 128);
  avg_time = call_kernel_1024_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 256);
  avg_time = call_kernel_1024_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 512);
  avg_time = call_kernel_1024_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 1024);
  avg_time = call_kernel_1024_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2, 2048);
  avg_time = call_kernel_1024_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 1);
  avg_time = call_kernel_1024_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 2);
  avg_time = call_kernel_1024_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 4);
  avg_time = call_kernel_1024_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 8);
  avg_time = call_kernel_1024_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 16);
  avg_time = call_kernel_1024_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 32);
  avg_time = call_kernel_1024_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 64);
  avg_time = call_kernel_1024_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 128);
  avg_time = call_kernel_1024_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 256);
  avg_time = call_kernel_1024_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 512);
  avg_time = call_kernel_1024_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 1024);
  avg_time = call_kernel_1024_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 4, 2048);
  avg_time = call_kernel_1024_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 1);
  avg_time = call_kernel_1024_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 2);
  avg_time = call_kernel_1024_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 4);
  avg_time = call_kernel_1024_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 8);
  avg_time = call_kernel_1024_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 16);
  avg_time = call_kernel_1024_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 32);
  avg_time = call_kernel_1024_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 64);
  avg_time = call_kernel_1024_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 128);
  avg_time = call_kernel_1024_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 256);
  avg_time = call_kernel_1024_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 512);
  avg_time = call_kernel_1024_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 1024);
  avg_time = call_kernel_1024_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 8, 2048);
  avg_time = call_kernel_1024_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 1);
  avg_time = call_kernel_1024_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 2);
  avg_time = call_kernel_1024_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 4);
  avg_time = call_kernel_1024_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 8);
  avg_time = call_kernel_1024_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 16);
  avg_time = call_kernel_1024_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 32);
  avg_time = call_kernel_1024_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 64);
  avg_time = call_kernel_1024_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 128);
  avg_time = call_kernel_1024_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 256);
  avg_time = call_kernel_1024_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 512);
  avg_time = call_kernel_1024_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 1024);
  avg_time = call_kernel_1024_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 16, 2048);
  avg_time = call_kernel_1024_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 1);
  avg_time = call_kernel_1024_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 2);
  avg_time = call_kernel_1024_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 4);
  avg_time = call_kernel_1024_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 8);
  avg_time = call_kernel_1024_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 16);
  avg_time = call_kernel_1024_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 32);
  avg_time = call_kernel_1024_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 64);
  avg_time = call_kernel_1024_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 128);
  avg_time = call_kernel_1024_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 256);
  avg_time = call_kernel_1024_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 512);
  avg_time = call_kernel_1024_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 1024);
  avg_time = call_kernel_1024_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 32, 2048);
  avg_time = call_kernel_1024_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 1);
  avg_time = call_kernel_1024_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 2);
  avg_time = call_kernel_1024_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 4);
  avg_time = call_kernel_1024_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 8);
  avg_time = call_kernel_1024_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 16);
  avg_time = call_kernel_1024_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 32);
  avg_time = call_kernel_1024_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 64);
  avg_time = call_kernel_1024_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 128);
  avg_time = call_kernel_1024_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 256);
  avg_time = call_kernel_1024_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 512);
  avg_time = call_kernel_1024_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 1024);
  avg_time = call_kernel_1024_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 64, 2048);
  avg_time = call_kernel_1024_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 1);
  avg_time = call_kernel_1024_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 2);
  avg_time = call_kernel_1024_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 4);
  avg_time = call_kernel_1024_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 8);
  avg_time = call_kernel_1024_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 16);
  avg_time = call_kernel_1024_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 32);
  avg_time = call_kernel_1024_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 64);
  avg_time = call_kernel_1024_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 128);
  avg_time = call_kernel_1024_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 256);
  avg_time = call_kernel_1024_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 512);
  avg_time = call_kernel_1024_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 1024);
  avg_time = call_kernel_1024_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 128, 2048);
  avg_time = call_kernel_1024_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 1);
  avg_time = call_kernel_1024_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 2);
  avg_time = call_kernel_1024_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 4);
  avg_time = call_kernel_1024_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 8);
  avg_time = call_kernel_1024_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 16);
  avg_time = call_kernel_1024_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 32);
  avg_time = call_kernel_1024_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 64);
  avg_time = call_kernel_1024_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 128);
  avg_time = call_kernel_1024_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 256);
  avg_time = call_kernel_1024_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 512);
  avg_time = call_kernel_1024_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 1024);
  avg_time = call_kernel_1024_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 256, 2048);
  avg_time = call_kernel_1024_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 1);
  avg_time = call_kernel_1024_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 2);
  avg_time = call_kernel_1024_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 4);
  avg_time = call_kernel_1024_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 8);
  avg_time = call_kernel_1024_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 16);
  avg_time = call_kernel_1024_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 32);
  avg_time = call_kernel_1024_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 64);
  avg_time = call_kernel_1024_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 128);
  avg_time = call_kernel_1024_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 256);
  avg_time = call_kernel_1024_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 512);
  avg_time = call_kernel_1024_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 1024);
  avg_time = call_kernel_1024_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 512, 2048);
  avg_time = call_kernel_1024_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 1);
  avg_time = call_kernel_1024_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 2);
  avg_time = call_kernel_1024_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 4);
  avg_time = call_kernel_1024_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 8);
  avg_time = call_kernel_1024_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 16);
  avg_time = call_kernel_1024_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 32);
  avg_time = call_kernel_1024_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 64);
  avg_time = call_kernel_1024_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 128);
  avg_time = call_kernel_1024_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 256);
  avg_time = call_kernel_1024_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 512);
  avg_time = call_kernel_1024_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 1024);
  avg_time = call_kernel_1024_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 1024, 2048);
  avg_time = call_kernel_1024_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 1);
  avg_time = call_kernel_1024_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 2);
  avg_time = call_kernel_1024_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 4);
  avg_time = call_kernel_1024_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 8);
  avg_time = call_kernel_1024_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 16);
  avg_time = call_kernel_1024_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 32);
  avg_time = call_kernel_1024_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 64);
  avg_time = call_kernel_1024_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 128);
  avg_time = call_kernel_1024_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 256);
  avg_time = call_kernel_1024_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 512);
  avg_time = call_kernel_1024_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 1024);
  avg_time = call_kernel_1024_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 1024, 2048, 2048);
  avg_time = call_kernel_1024_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {1024, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 1);
  avg_time = call_kernel_2048_1_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 2);
  avg_time = call_kernel_2048_1_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 4);
  avg_time = call_kernel_2048_1_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 8);
  avg_time = call_kernel_2048_1_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 16);
  avg_time = call_kernel_2048_1_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 32);
  avg_time = call_kernel_2048_1_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 64);
  avg_time = call_kernel_2048_1_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 128);
  avg_time = call_kernel_2048_1_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 256);
  avg_time = call_kernel_2048_1_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 512);
  avg_time = call_kernel_2048_1_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 1024);
  avg_time = call_kernel_2048_1_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1, 2048);
  avg_time = call_kernel_2048_1_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 1);
  avg_time = call_kernel_2048_2_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 2);
  avg_time = call_kernel_2048_2_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 4);
  avg_time = call_kernel_2048_2_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 8);
  avg_time = call_kernel_2048_2_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 16);
  avg_time = call_kernel_2048_2_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 32);
  avg_time = call_kernel_2048_2_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 64);
  avg_time = call_kernel_2048_2_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 128);
  avg_time = call_kernel_2048_2_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 256);
  avg_time = call_kernel_2048_2_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 512);
  avg_time = call_kernel_2048_2_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 1024);
  avg_time = call_kernel_2048_2_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2, 2048);
  avg_time = call_kernel_2048_2_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 1);
  avg_time = call_kernel_2048_4_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 2);
  avg_time = call_kernel_2048_4_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 4);
  avg_time = call_kernel_2048_4_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 8);
  avg_time = call_kernel_2048_4_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 16);
  avg_time = call_kernel_2048_4_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 32);
  avg_time = call_kernel_2048_4_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 64);
  avg_time = call_kernel_2048_4_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 128);
  avg_time = call_kernel_2048_4_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 256);
  avg_time = call_kernel_2048_4_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 512);
  avg_time = call_kernel_2048_4_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 1024);
  avg_time = call_kernel_2048_4_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 4, 2048);
  avg_time = call_kernel_2048_4_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 4, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 1);
  avg_time = call_kernel_2048_8_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 2);
  avg_time = call_kernel_2048_8_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 4);
  avg_time = call_kernel_2048_8_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 8);
  avg_time = call_kernel_2048_8_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 16);
  avg_time = call_kernel_2048_8_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 32);
  avg_time = call_kernel_2048_8_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 64);
  avg_time = call_kernel_2048_8_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 128);
  avg_time = call_kernel_2048_8_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 256);
  avg_time = call_kernel_2048_8_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 512);
  avg_time = call_kernel_2048_8_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 1024);
  avg_time = call_kernel_2048_8_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 8, 2048);
  avg_time = call_kernel_2048_8_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 8, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 1);
  avg_time = call_kernel_2048_16_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 2);
  avg_time = call_kernel_2048_16_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 4);
  avg_time = call_kernel_2048_16_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 8);
  avg_time = call_kernel_2048_16_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 16);
  avg_time = call_kernel_2048_16_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 32);
  avg_time = call_kernel_2048_16_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 64);
  avg_time = call_kernel_2048_16_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 128);
  avg_time = call_kernel_2048_16_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 256);
  avg_time = call_kernel_2048_16_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 512);
  avg_time = call_kernel_2048_16_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 1024);
  avg_time = call_kernel_2048_16_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 16, 2048);
  avg_time = call_kernel_2048_16_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 16, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 1);
  avg_time = call_kernel_2048_32_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 2);
  avg_time = call_kernel_2048_32_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 4);
  avg_time = call_kernel_2048_32_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 8);
  avg_time = call_kernel_2048_32_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 16);
  avg_time = call_kernel_2048_32_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 32);
  avg_time = call_kernel_2048_32_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 64);
  avg_time = call_kernel_2048_32_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 128);
  avg_time = call_kernel_2048_32_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 256);
  avg_time = call_kernel_2048_32_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 512);
  avg_time = call_kernel_2048_32_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 1024);
  avg_time = call_kernel_2048_32_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 32, 2048);
  avg_time = call_kernel_2048_32_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 32, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 1);
  avg_time = call_kernel_2048_64_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 2);
  avg_time = call_kernel_2048_64_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 4);
  avg_time = call_kernel_2048_64_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 8);
  avg_time = call_kernel_2048_64_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 16);
  avg_time = call_kernel_2048_64_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 32);
  avg_time = call_kernel_2048_64_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 64);
  avg_time = call_kernel_2048_64_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 128);
  avg_time = call_kernel_2048_64_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 256);
  avg_time = call_kernel_2048_64_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 512);
  avg_time = call_kernel_2048_64_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 1024);
  avg_time = call_kernel_2048_64_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 64, 2048);
  avg_time = call_kernel_2048_64_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 64, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 1);
  avg_time = call_kernel_2048_128_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 2);
  avg_time = call_kernel_2048_128_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 4);
  avg_time = call_kernel_2048_128_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 8);
  avg_time = call_kernel_2048_128_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 16);
  avg_time = call_kernel_2048_128_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 32);
  avg_time = call_kernel_2048_128_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 64);
  avg_time = call_kernel_2048_128_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 128);
  avg_time = call_kernel_2048_128_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 256);
  avg_time = call_kernel_2048_128_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 512);
  avg_time = call_kernel_2048_128_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 1024);
  avg_time = call_kernel_2048_128_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 128, 2048);
  avg_time = call_kernel_2048_128_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 128, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 1);
  avg_time = call_kernel_2048_256_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 2);
  avg_time = call_kernel_2048_256_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 4);
  avg_time = call_kernel_2048_256_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 8);
  avg_time = call_kernel_2048_256_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 16);
  avg_time = call_kernel_2048_256_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 32);
  avg_time = call_kernel_2048_256_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 64);
  avg_time = call_kernel_2048_256_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 128);
  avg_time = call_kernel_2048_256_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 256);
  avg_time = call_kernel_2048_256_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 512);
  avg_time = call_kernel_2048_256_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 1024);
  avg_time = call_kernel_2048_256_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 256, 2048);
  avg_time = call_kernel_2048_256_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 256, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 1);
  avg_time = call_kernel_2048_512_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 2);
  avg_time = call_kernel_2048_512_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 4);
  avg_time = call_kernel_2048_512_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 8);
  avg_time = call_kernel_2048_512_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 16);
  avg_time = call_kernel_2048_512_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 32);
  avg_time = call_kernel_2048_512_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 64);
  avg_time = call_kernel_2048_512_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 128);
  avg_time = call_kernel_2048_512_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 256);
  avg_time = call_kernel_2048_512_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 512);
  avg_time = call_kernel_2048_512_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 1024);
  avg_time = call_kernel_2048_512_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 512, 2048);
  avg_time = call_kernel_2048_512_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 512, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 1);
  avg_time = call_kernel_2048_1024_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 2);
  avg_time = call_kernel_2048_1024_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 4);
  avg_time = call_kernel_2048_1024_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 8);
  avg_time = call_kernel_2048_1024_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 16);
  avg_time = call_kernel_2048_1024_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 32);
  avg_time = call_kernel_2048_1024_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 64);
  avg_time = call_kernel_2048_1024_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 128);
  avg_time = call_kernel_2048_1024_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 256);
  avg_time = call_kernel_2048_1024_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 512);
  avg_time = call_kernel_2048_1024_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 1024);
  avg_time = call_kernel_2048_1024_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 1024, 2048);
  avg_time = call_kernel_2048_1024_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 1024, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 1);
  avg_time = call_kernel_2048_2048_1();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 1};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 2);
  avg_time = call_kernel_2048_2048_2();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 2};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 4);
  avg_time = call_kernel_2048_2048_4();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 4};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 8);
  avg_time = call_kernel_2048_2048_8();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 8};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 16);
  avg_time = call_kernel_2048_2048_16();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 16};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 32);
  avg_time = call_kernel_2048_2048_32();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 32};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 64);
  avg_time = call_kernel_2048_2048_64();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 64};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 128);
  avg_time = call_kernel_2048_2048_128();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 128};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 256);
  avg_time = call_kernel_2048_2048_256();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 256};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 512);
  avg_time = call_kernel_2048_2048_512();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 512};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 1024);
  avg_time = call_kernel_2048_2048_1024();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 1024};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("(mc: %d, nc: %d, kc: %d)\n", 2048, 2048, 2048);
  avg_time = call_kernel_2048_2048_2048();
  if (avg_time < min_time) {
    min_time = avg_time;
    struct Param new_param = {2048, 2048, 2048};
    min_param = new_param;
  }
  tee("Current best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  tee("Best params: (mc: %d, nc: %d, kc: %d): %lds %09ldns\n",
      min_param.mc, min_param.nc, min_param.kc, ToTs(min_time).tv_sec,
      ToTs(min_time).tv_nsec);

  return 0;
}

